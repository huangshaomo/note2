# 计算机原理

## 进制转换

### 二进制转十进制

> 把二进制数按权展开，相加即得十进制数

**例如 1001 0110**

![image-20200418113903619](D:/Typora/typora-user-images/计算机原理/image-20200418113903619.png)

### 十进制转二进制

> 十进制数除2取余法，即10进制数除2，余数为权位上的数，得到的商值继续除，直到商为0为止

**例如：150**

![image-20200418114013859](D:/Typora/typora-user-images/计算机原理/image-20200418114013859.png)

### 十六进制转十进制

> 把16进制按权展开，相加即得十进制数

![image-20200418120732560](D:/Typora/typora-user-images/计算机原理/image-20200418120732560.png)



### 十进制转十六进制

> 用10进制数除以16取余

![image-20200418120235700](D:/Typora/typora-user-images/计算机原理/image-20200418120235700.png)



### 八进制转十进制

> 把八进制按权展开，相加即得十进制

![image-20200418140404815](D:/Typora/typora-user-images/计算机原理/image-20200418140404815.png)

### 十进制转八进制

> 用10进制数除以8取余

![image-20200418141226208](D:/Typora/typora-user-images/计算机原理/image-20200418141226208.png)





**总结：**

- 2、8、16进制转10进制，都是按权展开
- 10进制转2、8、16进制，都是用10 进制除以待转进制数取余，取余数从下往上，越前位数越大。



## 位运算

> 位运算的计算都是以补码的方式进行的, 因为计算机底层都是以补码进行计算的

### 左移  << 

举个栗子，5 << 2  将5左移2  结果为20  为啥？注意是对二进制进行的操作，来看：

首先会将5转为二进制表示形式(java中，整数默认就是int类型,也就是32位):

![在这里插入图片描述](D:/Typora/typora-user-images/计算机原理/16fb3fae1e139d8c)


怎么去理解，首先在Java中，整数默认就是int类型，也就是占4个字节32位，你就可以想成这样



```
0000 0000 0000 0000 0000 0000 0000 0000
```



这就是32位，但是每位上都是0，这是一个标准，用于后面的比较，比如5的二进制是

```
0000 0000 0000 0000 0000 0000 0000 0101
```



然后把它与标准的进行对比，也就是这样：

![在这里插入图片描述](D:/Typora/typora-user-images/计算机原理/16fb3fae1e2a5793)


这时候的区别就在后四位，然后将5左移（<<）2，也就是5的二进制以标准为参考整体左移2位，也就是这样：



![在这里插入图片描述](D:/Typora/typora-user-images/计算机原理/16fb3fae408d819d)
这样一来，就产生了错位，看图：

![在这里插入图片描述](D:/Typora/typora-user-images/计算机原理/16fb3fae40df0a5e)在这里插入图片描述


不过这时候看着总是有点别扭，应该都是四位四位的在一块吧，所以从低位开始，四位一组，就成了这样
0000 0000 0000 0000 0000 0000 0001 0100 



换算成十进制就是20了 这就是5 << 2得到结果的由来。



### 右移 >> 

还是先将5转为2进制表示形式：
0000 0000 0000 0000 0000 0000 0000 0101 然后右移2位，高位补0：
0000 0000 0000 0000 0000 0000 0000 0001

看图：

![在这里插入图片描述](D:/Typora/typora-user-images/计算机原理/16fb3fae4449ea79)在这里插入图片描述


仔细看图分析分析😃



### 无符号右移 >>> 

先记住这句话：**正数右移，高位补0，负数右移，高位补1，负数无符号右移，高位补0  正数无符号右移 ，高位补0     正数换算成二进制后的最高位为0，负数的二进制最高位为1**

接下来依然是看例子，在此之前我看过好多别人写的，发现好多都喜欢用5举例子你知道为啥吗😂

5换算成二进制是： 0000 0000 0000 0000 0000 0000 0000 0101

5右移3位后结果为0，0的二进制为： 0000 0000 0000 0000 0000 0000 0000 0000        // (这里高位补0)

-5换算成二进制是： 1111 1111 1111 1111 1111 1111 1111 1011 补

-5右移3位后结果为-1，-1的二进制为： 1111 1111 1111 1111 1111 1111 1111 1111   // (高位补1，补码转原码，除最高位，先-1再取反)

-5无符号右移3位后的结果 536870911 换算成二进制： 0001 1111 1111 1111 1111 1111 1111 1111   // (高位补0)

这里需要注意了：**以上说的都是右移的情况，如果是左移，无论是正数还是负数，低位都是用0补**

时间关系，就不赘述了。



### (and)位与 & 

> 全1则1，否则为0

其实核心都是二进制，所以掌握好进制转换是关键，看看位与 &是怎么计算的：

![在这里插入图片描述](D:/Typora/typora-user-images/计算机原理/16fb3fae4450936e)
这里要看两个操作数的二进制的各个位的对应情况，总结起来也就是：



> 全1则1，否则为0

什么意思呢？我们举一个例子来看看

![在这里插入图片描述](D:/Typora/typora-user-images/计算机原理/16fb3fae4451278c)


我们猜这个结果是什么，答案是



![在这里插入图片描述](D:/Typora/typora-user-images/计算机原理/16fb3fae45a327b2)


注意这里可不是6除以3，它是这样计算的，首先6和3都要转成二进制，6的二进制是110，3的二进制是11也就是011，那么这样运算



![在这里插入图片描述](D:/Typora/typora-user-images/计算机原理/16fb3fae66e264a4)


我相信看图就能明白的，而二进制的010就是2啦，这就是位与的操作，对于或和亦或其实同样道理，我们继续来看：



### (or)位或 | 

> 有1就为1，没1则0

看例子：

![在这里插入图片描述](D:/Typora/typora-user-images/计算机原理/16fb3fae678b57db)





### (XOR)位异或 ^ 

> 有1则1，全1则0

看例子：

![在这里插入图片描述](D:/Typora/typora-user-images/计算机原理/16fb3fae6ae69d3f)



### 位非 ~ 

> 把数字转为二进制补码，然后再全部取反，取反后的该数值是补码，最后再转为原码，得到的原码就是最终的结果

这是网站随便找的一个例子，你看看，求~5，得-6，为啥？

![在这里插入图片描述](D:/Typora/typora-user-images/计算机原理/16fb3fae6adafaeb)





~5的计算：

​	5的二进制位 0000 0101（以8位进行描述）

​	正数的补码就是原码

​	5的补码：0000 0101 补

​	~5：		 1111  1010 （补）

​	第一号为符号为：

​	所以~5的原码：1000 0100 = -6



### 什么是符号位

> 计算机保存正负号的区别是，用第一个位（最左边的）去表示正负，0为正数，1为负数，而这个用作表示正负符号的位就叫做符号位



## 原码，补码，反码

> 原码：可直观反映出数据的大小。
>
> 反码：解决负数加法运算问题，将减法运算转换为加法运算，从而简化运算规则。
>
> 补码：解决负数加法运算正负零问题，弥补了反码的不足。
>
> 有人会有疑惑为什么要用反码，补码，不直接用原码呢？先搞清楚一点反码补码原码是针对二进制数而言，计算机若用原码相加减，正数加正数不会出错，然而正数和负数原码相加就会出错。

![image-20200417173119172](D:/Typora/typora-user-images/计算机原理/image-20200417173119172.png)

引进补码的作用是为了让计算机更方便做减法 

说白了,补码反码就是为了简化减法而来的,将减号化为负数 再将负数化为补码求加法 跟正数没关系 ，不管是正整数还是正小数,原码,反码,补码都全部相同。

**事实证明计算机中负数是以补码存储的，也可以推广到，计算机中所有数都是以补码形式存储的。**

四：剖析本质：

1.单字节无符号的正数可以存储的范围就是 0~256 二进制表示（ 0000 0000~1111 1111）

2.单字节有负号的整数可以存储的范围是-128 ~127 。

先看正数二进制能表示范围（0 000 0001 ~ 0 111 1111）即1~127

 

负数二进制能能表示的范围（1 000  0001 ~ 1 111 1111）即-127~-1

所还有个0 分为+0和-0 (0000 0000 表示+0，1000 0000 表示-0 表示-128)



### 原码

> 对于 正数 来说，我们把它的绝对值转换成的二进制码叫做正数的原码
>
> 对于 负数 来说，我们把它的绝对值转换成的二进制码数，然后最高位补1，陈之为原码

5的原码

```txt
00000101
```

-5的原码

```javascript
10000101
```

这里有个点就是最高位是0代表正数，是1代表



**原码例子：以5-5=0为例**

```text
5-5 = 5+(-5) =
	0000 0101 原
+	1000 0101 原
----------------
=   1000 1010 原 = 10
```

如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的，这也就是为何计算机内部不使用原码的原因



### 反码

> 对于 正数 来说，正数的反码是其本身
>
> 对于 负数 来说，负数的反码为在该负数原码的基础上，除了符号位（最高位）不变，其余位取反

5的反码

```text
00000000 00000000 00000000 00000101
```

-5的反码

```text
//首先，在负数原码的基础上
10000000 00000000 00000000 00000101
//除符号位以外，其余位全部取反
11111111 11111111 11111111 11111010
```



**反码例子：以5-5=0为例**

```text
5-5 = 5+(-5) =
	0000 0101 原
+   1000 0101 原
----------------
	0000 0101 反
+   1111 1010 反
----------------
=	1111 1111 反
----------------
=	1000 0000 原 = -0

```

发现用反码计算减法，结果的真值部分是正确的，而唯一的问题就出现在0这个特殊的数值上，虽然人们理解上+0和-0是一样的，但是0带符号显然是没有任何意义的，而且这里还有一个问题，那就是 +0 和 -0，用原码和反码表示的时候，都有两种表示法：

原码

```javascript
[+0]原=00000000

[-0]原=10000000
```

反码

```javascript
[+0]反=00000000

[-0]反=11111111
```

这就有点难受啊，不都是0吗，于是乎，就出了补码



### 补码

> 对于 正数 来说，补码就是其本身
>
> 对于 负数 来说，补码就是在该负数原码的基础上，符号位不变，其余位取反，最后+1

5的补码

```
00000000 00000000 00000000 00000101
```

-5的补码

```
//首先，在负数原码的基础上
10000000 00000000 00000000 00000101
//除符号位外，其余位取反，最后+1
11111111 11111111 11111111 11111011
```



**补码例子1：以5-5=0为例**

```text
5-5 = 5+(-5) = 
	0000 0101 原
+ 	1000 0101 原
----------------
	0000 0101 补
-	1111 1011 补
----------------
= 1 0000 0000 补 (出现了一个9位二进制数，所以去除一位，变成)
----------------
=	0000 0000 补	得到的结果是正数，正数的的原码还是本身
----------------
=	0000 0000 原
```

这样0用[0000 0000]表示,而以前出现问题的-0则不存在了。而且可以用[1000 0000]表示-128

**补码例子2：以5-6=-1为例**

```text
5-6 = 5+(-6) = 
	0000 0101 原
+ 	1000 0110 原
----------------
	0000 0101 补
+	1111 1010 补
----------------
=	1111 1111 补	得到的结果是负数数，负数的原码是符号位不变，其余位取反，最后-1
----------------
=   1000 0001 原 = -1
```



**补码例子3：以-1 - 127 = -128为例**

```text
-1-127 = -1+(-127) = 
	1000 0001 原
+   1111 1111 补
----------------
	1111 1111 补
+   1000 0001 补
----------------
= 1 1000 0000 补 (出现了一个9位二进制数，所以去除一位，变成)
----------------
= 	1000 0000 补
----------------
= 	0111 1110
```

-1-127的结果应该是128，在用补码运算的结果中，[1000 0000]补 就是-128。但是注意因为实际上使用以前的-0的补码来表示-128，所以**-128并没有原码和反码表示**。（对-128的补码表示 [1000 0000]补算出来的原码是[0000 0000]原，这是不正确的）

从上述说明中，我们可以得知，通过使用补码，可以将减法变成加法，更符合计算机的运行规则。



这里有两点需要注意：

1、从补码求原码的方法与原码求补码是一样的，也可以通过完全逆运算来做，先减一，再取反

2、补码规定0没有正负之分，也就是对于0来说，补码只有一样[-0]补 = 00000000。



#### 补码的本质

以-8为例，-8其实就是0-8

```text
	0000 0000
- 	0000 1000
-------------
因为被减数([0000 0000])小于减数([0000 1000])，所以需要向上接一位,被减数就变成了[1 0000 0000]，上面的式子也就成了
  1 0000 0000
-   0000 1000
-------------
=	1111 1000
其实上面的[1 0000 0000] = [1111 1111] + [0000 0001]，所以上面的式子可以分解成
 	1111 1111
-	0000 1000
-------------
	1111 0111
+	0000 0001
--------------
=	1111 1000
```

补码的两个步骤就是这么来的



### 总结：

- 原码表示法规定：用符号位（最左边）和数值表示带符号数，正数的符号位用**0**表示，负数的符号位用**1**表示，数值部分用二进制形式表示。
- 反码表示法规定：正数的反码与原码相同，负数的反码为在该负数原码的基础上，除符号位以外的其他位全部取反。
- 补码表示法规定：正数的补码与原码相同，负数的补吗为在该负数原码的基础上，除符号位以外的其他位全部取反，并且在最后一个加1。
- 0 和 -0 的补码相同，[+0]补 = [-0]补 = 0000 0000B
- **原码转补码：除符号位，先取反再+1**
- **补码转原码：除符号位，先-1再取反**





## 字符编码

> 所谓字符编码，就是按照某种格式某种规定将字符存储在计算机中。

**常见字符编码**

![image-20200418141537601](D:/Typora/typora-user-images/计算机原理/image-20200418141537601.png)

**换算单位**

> 很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们看到8个开关状态是好的，于是他们把这称为”**字节**“。再后来，他们又做了一些可以处理这些字节的机器，机器开动了，可以用字节来组合出很多状态，状态开始变来变去。他们看到这样是好的，于是它们就这机器称为”**计算机**“。

bit 位，计算机中最小的表示单位

8bit = 1bytes 字节，最小的存储单位，1bytes缩写为1B

1KB=1024B

1MB=1024KB

1GB=1024MB

1TB=1024GB





### ASCII编码

> 开始计算机只在美国用。八位的字节一共可以组合出256(2的8次方)种不同的状态。 
> 他们把其中的编号从0开始的32种状态分别规定了特殊的用途，一但终端、打印机遇上约定好的这些字节被传过来时，就要做一些约定的动作：
>
> 遇上0×10, 终端就换行；
>
> 遇上0×07, 终端就向人们嘟嘟叫；
>
> 遇上0x1b, 打印机就打印反白的字，或者终端就用彩色显示字母。
>
> 他们看到这样很好，于是就把这些0×20以下的字节状态称为”控制码”。他们又把所有的空 
> 格、标点符号、数字、大小写字母分别用连续的字节状态表示，一直编到了第127号，这样计算机就可以用不同字节来存储英语的文字了。大家看到这样，都感觉
>  很好，于是大家都把这个方案叫做 **ANSI** 的”Ascii”编码（American Standard Code for Information Interchange，美国信息互换标准代码）。当时世界上所有的计算机都用同样的**ASCII**方案来保存英文文字。
>
> 
>
> 后来，就像建造巴比伦塔一样，世界各地都开始使用计算机，但是很多国家用的不是英文，他们的字母里有许多是ASCII里没有的，为了可以在计算机保存他们的文字，他们决定采用 
> 127号之后的空位来表示这些新的字母、符号，还加入了很多画表格时需要用下到的横线、竖线、交叉等形状，一直把序号编到了最后一个状态255。从128 到255这一页的字符集被称”**扩展字符集**“。从此之后，贪婪的人类再没有新的状态可以用了，美帝国主义可能没有想到还有第三世界国家的人们也希望可以用到计算机吧！

![image-20200417160715813](D:/Typora/typora-user-images/计算机原理/image-20200417160715813.png)

数字0-9 ：48-57

大写字母A-Z：65-90

小写字母a-z：97-122



### GB2312编码

>  等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节176-367）从0xA1用到0xF7，后面一个字节（低字节）从0xA1到0xFE(167 - 376)，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。中国人民看到这样很不错，于是就把这种汉字方案叫做 “**GB2312**“。GB2312 是对 ASCII 的中文扩展。

![image-20200418143024703](D:/Typora/typora-user-images/计算机原理/image-20200418143024703.png)



### GBK编码

> 但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把GB2312 没有用到的码位找出来老实不客气地用上。后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字
> 符集里的内容。结果扩展之后的编码方案被称为 **GBK** 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号。 后来少数民族也要用电脑了，于是我们再扩展，又加了几千个新的少数民族的字，GBK扩成了 **GB18030**。从此之后，中华民族的文化就可以在计算机时代中传承了。 中国的程序员们看到这一系列汉字编码的标准是好的，于是通称他们叫做 “**DBCS**“（Double Byte Charecter Set 双字节字符集）。在DBCS系列标准里，最大的特点是两字节长的汉字字符和一字节长的英文字符并存于同一套编码方案里，因此他们写的程序为了支持中文处理，必须要注意字串里的每一个字节的值，如果这个值是大于127的，那么就认为一个双字节字符集里的字符出现了。那时候凡是受过加持，会编程的计算机僧侣们都要每天念下面这个咒语数百遍： “一个汉字算两个英文字符！一个汉字算两个英文字符……”

![image-20200418144111712](D:/Typora/typora-user-images/计算机原理/image-20200418144111712.png)



### Unicode编码

>  因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码，连大陆和台湾这样只相隔了150海里，使用着同一种语言的兄弟地区，也分别采用了不同的 DBCS 编码方案——当时的中国人想让电脑显示汉字，就必须装上一个”汉字系统”，专门用来处理汉字的显示、输入的问题，像是那个台湾的愚昧封建人士写的算命程序就必须加装另一套支持 BIG5 编码的什么”倚天汉字系统”才可以用，装错了字符系统，显示就会乱了套！这怎么办？而且世界民族之林中还有那些一时用不上电脑的穷苦人民，他们的文字又怎么办？ 真是计算机的巴比伦塔命题啊！

> 正在这时，大天使加百列及时出现了——一个叫 **ISO**（国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号 的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 **UCS**, 俗称 “**unicode**“。

![image-20200418144327311](D:/Typora/typora-user-images/计算机原理/image-20200418144327311.png)





### UTF-8

> unicode开始制订时，计算机的存储器容量极大地发展了，空间再也不成为问题了。于是 ISO 
> 就直接规定必须用两个字节，也就是16位来统一表示所有的字符，对于ASCII里的那些“半角”字符，unicode包持其原编码不变，只是将其长度由原来的8位扩展为16位，而其他文化和语言的字符则全部重新统一编码。由于”半角”英文符号只需要用到低8位，所以其高8位永远是0，因此这种大气的方案在保存英文文本时会多浪费一倍的空间。



> 这时候，从旧社会里走过来的程序员开始发现一个奇怪的现象：他们的 *strlen* 函数靠不住了，一个汉字不再是相当于两个字符了，而是一个！是的，从unicode开始，无论是半角的英文字母，还是全角的汉字，它们都是统一的”**一个字符**“！同时，也都是统一的”**两个字节**“，请注意”字符”和”字节”两个术语的不同，“**字节**”是一个8位的物理存贮单元，而“**字符**”则是一个文化相关的符号。在unicode中，一个字符就是两个字节。一个汉字算两个英文字符的时代已经快过去了。



> unicode同样也不完美，这里就有两个的问题，一个是，如何才能区别unicode和ascii？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。



> unicode在很长一段时间内无法推广，直到互联网的出现，为解决unicode如何在网络上传输的问题，于是面向传输的众多 **UTF**（UCS Transfer Format）标准出现了，顾名思义，**UTF-8**就是每次8个位传输数据，而**UTF-16**就是每次16个位。UTF-8就是在互联网上使用最广的一种unicode的实现方式，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度，当字符在ASCII码的范围时，就用一个字节表示，保留了ASCII字符一个字节的编码做为它的一部分，注意的是unicode一个中文字符占2个字节，而UTF-8一个中文字符占3个字节）。从unicode到utf-8并不是直接的对应，而是要过一些算法和规则来转换。

![image-20200418144517456](D:/Typora/typora-user-images/计算机原理/image-20200418144517456.png)



**unicode与utf-8的区别**

​	unicode是一个字符集，里面几乎包含了目前世界上已知的所有字符，且该字符集将二进制代码和字符形成一一映射，即一个字符对应且只对应一个二进制代码，反过来，一个二进制代码对应且只对应一个字符。

​	如果我们有一个字符，那么通过Unicode字符集很容易找到该字符对应的二进制码，但是，反过来，如果我们有某个字符的二进制码，通过该二进制码去查找对应的字符可能会出现混乱，为什么呢？情境如下：如果我们假设Unicode字符集有两个字符，比如说（这里我没有查阅Unicode字符集，虚构了两个，只是打个比方，请各位看官不要较劲）：1100 1111 1111 0001 1111 0101 对应字符‘我’，一共三个字节，1100 1111 1111 0001对应字符‘你’，一共两个字节，恰好是‘我’这个字符二进制码的前两个字节。如果我们存的是‘我’即三个字节的那个代码，即1100 1111 1111 0001 1111 0101，然后让计算机进行解码时，它会从左向右依次读取一个数码，当读到1100 1111 1111 0001时它可能就停止，让‘你’这个字符与其对应，并不是我们当初想存的‘我’这个字符，只是因为这两个字符对应的二进制码前两个字节是一样的，这就是一个问题。Unicode字符集中对字符的编码是长度不确定的，其中有的字符是两个字符，有的是三个字符，这给计算机进行解码带来了困难（就像上述描述的情境），所以我们想给每个字符对应的二进制码前加上一个标记，让计算机看到这个标记就知道它将要读取几个字节，这样就防止了上述描述的两个字符因为前两个字节编码相同而误将三个字节的字符当成两个字节的字符读取了这种错误，那么这个标记该怎么加呢？这就导致人们引入UTF-8，它的英文全称是8-bit Unicode Transformation Format，可以看出它是将原本的Unicode码进行了transformation，这种transformation 就是给每个Unicode码进行标记，使得让计算机看到某个标记就知道待会要读取几个字节的代码，从而避免问题发生。因此，我觉得utf-8的引入，最主要的原因

```text
I 00000000 01001001
t 00000000 01110100
' 00000000 00100111
s 00000000 01110011
  00000000 00100000
知 01110111 11100101
乎 01001110 01001110
日 01100101 11100101
报 01100010 10100101
```

总结一句话：utf8是对unicode字符集进行编码的一种编码方式。



```
Unicode符号范围 |UTF-8编码方式
(十六进制) |  （二进制）
—————————————————————–
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx


```



最后简单总结一下：

- 中国人民通过对 ASCII 编码的中文扩充改造，产生了 GB2312 编码，可以表示6000多个常用汉字。
- 汉字实在是太多了，包括繁体和各种字符，于是产生了 GBK 编码，它包括了 GB2312 中的编码，同时扩充了很多。
- 中国是个多民族国家，各个民族几乎都有自己独立的语言系统，为了表示那些字符，继续把 GBK 编码扩充为 GB18030 编码。
- 每个国家都像中国一样，把自己的语言编码，于是出现了各种各样的编码，如果你不安装相应的编码，就无法解释相应编码想表达的内容。
- 终于，有个叫 ISO 的组织看不下去了。他们一起创造了一种编码 UNICODE ，这种编码非常大，大到可以容纳世界上任何一个文字和标志。所以只要电脑上有 UNICODE 这种编码系统，无论是全球哪种文字，只需要保存文件的时候，保存成 UNICODE 编码就可以被其他电脑正常解释。
- UNICODE 在网络传输中，出现了两个标准 UTF-8 和 UTF-16，分别每次传输 8个位和 16个位。于是就会有人产生疑问，UTF-8 既然能保存那么多文字、符号，为什么国内还有这么多使用 GBK 等编码的人？因为 UTF-8 等编码体积比较大，占电脑空间比较多，如果面向的使用人群绝大部分都是中国人，用 GBK 等编码也可以。utf-8中文字符占3个字节，而GBK占两个字节